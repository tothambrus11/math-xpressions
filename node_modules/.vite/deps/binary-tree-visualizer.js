// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/config/theme.js
var theme = {
  radius: 20,
  growthAndShrinkTimes: 1.25,
  leafNodeSpace: 75,
  lineHeight: 90,
  fontSize: 10,
  textFont: "Poppins",
  strokeColor: "#f56042",
  colorArray: [
    { bgColor: "#fff2e0", borderColor: "#f56042" }
  ]
};
function setTheme(userDefinedTheme) {
  const { radius = theme.radius, growthAndShrinkTimes = theme.growthAndShrinkTimes, leafNodeSpace = theme.leafNodeSpace, lineHeight = theme.lineHeight, colorArray = theme.colorArray, textFont = theme.textFont, strokeColor = theme.strokeColor, fontSize = theme.fontSize } = userDefinedTheme;
  theme.radius = radius;
  theme.growthAndShrinkTimes = growthAndShrinkTimes;
  theme.leafNodeSpace = leafNodeSpace;
  theme.lineHeight = lineHeight;
  theme.colorArray = colorArray;
  theme.textFont = textFont;
  theme.strokeColor = strokeColor;
  theme.fontSize = fontSize;
}
var theme_default = theme;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/shapes/Circle.js
var growthRate = 0.3;
var Circle = class {
  constructor(value, radius, colorSettings) {
    this.colorId = "";
    this.x = -1;
    this.y = -1;
    this.value = value;
    this.colorSettings = colorSettings;
    this.radiusSettings = {
      currentRadius: radius,
      originalRadius: radius,
      maxRadius: radius * theme_default.growthAndShrinkTimes,
      minRadius: radius / theme_default.growthAndShrinkTimes
    };
  }
  drawCircle(ctx, radius, color) {
    const { x, y } = this;
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, Math.PI * 2, false);
    ctx.fill();
  }
  drawBorder(ctx) {
    const { x, y, colorSettings, radiusSettings: { currentRadius: radius } } = this;
    const { borderColor } = colorSettings;
    ctx.arc(x, y, radius, 0, Math.PI * 2, false);
    ctx.strokeStyle = borderColor;
    ctx.stroke();
  }
  writeText(ctx) {
    const { x, y, value, colorSettings } = this;
    const { borderColor } = colorSettings;
    const fontSize = `${theme_default.fontSize}pt`;
    const ySpacing = theme_default.fontSize / 2;
    ctx.fillStyle = borderColor;
    ctx.font = `${fontSize} ${theme_default.textFont}`;
    ctx.textAlign = "center";
    ctx.fillText(value, x, y + ySpacing);
  }
  getRadius() {
    const { radiusSettings: { currentRadius: radius } } = this;
    return radius;
  }
  grow(maxRadius = this.radiusSettings.maxRadius) {
    const { radiusSettings: { currentRadius } } = this;
    if (currentRadius < maxRadius) {
      const originalIncreasedRadius = currentRadius + growthRate;
      this.radiusSettings.currentRadius = originalIncreasedRadius > maxRadius ? maxRadius : originalIncreasedRadius;
      return true;
    }
    return false;
  }
  shrink(minRadius = this.radiusSettings.minRadius) {
    const { radiusSettings: { currentRadius } } = this;
    if (currentRadius > minRadius) {
      const originalDecreasedRadius = currentRadius - growthRate;
      this.radiusSettings.currentRadius = originalDecreasedRadius < minRadius ? minRadius : originalDecreasedRadius;
      return true;
    }
    return false;
  }
  restoreCircle() {
    const { radiusSettings: { currentRadius, originalRadius } } = this;
    if (currentRadius > originalRadius) {
      return this.shrink(originalRadius);
    }
    if (currentRadius < originalRadius) {
      return this.grow(originalRadius);
    }
    return false;
  }
  setColorId(colorId) {
    this.colorId = colorId;
  }
  setCoordinates(x, y) {
    this.x = x;
    this.y = y;
  }
  draw(comp) {
    const { radiusSettings: { currentRadius: radius }, colorSettings: { bgColor } } = this;
    this.colorId = this.colorId ? this.colorId : comp.getNextColor();
    this.drawCircle(comp.getContext(), radius, bgColor);
    this.drawCircle(comp.getHitContext(), radius, this.colorId);
    this.drawBorder(comp.getContext());
    this.writeText(comp.getContext());
    return this.colorId;
  }
};
var Circle_default = Circle;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/utils/getRandomColor.js
function getRandomColor() {
  const { colorArray } = theme_default;
  return colorArray[Math.floor(Math.random() * colorArray.length)];
}
var getRandomColor_default = getRandomColor;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/tree/BinaryTreeNode.js
var BinaryTreeNode = class {
  constructor(value) {
    this.value = value;
    this.nodeCircle = new Circle_default(`${value}`, theme_default.radius, getRandomColor_default());
  }
  setLeft(value) {
    this.left = value;
  }
  setRight(value) {
    this.right = value;
  }
  getHeight() {
    var _a, _b;
    const leftHeight = ((_a = this.left) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;
    const rightHeight = ((_b = this.right) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;
    return Math.max(leftHeight, rightHeight) + 1;
  }
};
var BinaryTreeNode_default = BinaryTreeNode;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/tree/BinarySearchTreeNode.js
var BinarySearchTreeNode = class extends BinaryTreeNode_default {
  setLeft(value) {
    super.setLeft(value);
  }
  setRight(value) {
    super.setRight(value);
  }
  insert(value) {
    if (value === this.value) {
      return;
    }
    if (value < this.value) {
      if (this.left) {
        this.left.insert(value);
        return;
      }
      this.setLeft(new BinarySearchTreeNode(value));
      return;
    }
    if (this.right) {
      this.right.insert(value);
      return;
    }
    this.setRight(new BinarySearchTreeNode(value));
  }
  findMinimum() {
    if (this.left) {
      return this.left.findMinimum();
    }
    return this;
  }
  deleteThisNode(parent) {
    const childDirection = (parent === null || parent === void 0 ? void 0 : parent.left) === this ? "left" : "right";
    if (!this.left && !this.right) {
      if (parent) {
        delete parent[childDirection];
      }
      return [this];
    }
    if (this.left && !this.right) {
      if (parent) {
        parent[childDirection] = this.left;
      }
      return [this, this.left];
    } else if (this.right && !this.left) {
      if (parent) {
        parent[childDirection] = this.right;
      }
      return [this, this.right];
    }
    const [deletedNode] = this.right.delete(this.right.findMinimum().value, this);
    deletedNode.left = this.left;
    deletedNode.right = this.right;
    if (parent) {
      parent[childDirection] = deletedNode;
    }
    return [this, deletedNode];
  }
  delete(value, parent) {
    if (value < this.value && this.left) {
      const [deletedNode] = this.left.delete(value, this);
      return [deletedNode, this];
    }
    if (value > this.value && this.right) {
      const [deletedNode] = this.right.delete(value, this);
      return [deletedNode, this];
    }
    if (this.value === value) {
      const res = this.deleteThisNode(parent);
      delete this.left;
      delete this.right;
      return res;
    }
    return [, this];
  }
};
var BinarySearchTreeNode_default = BinarySearchTreeNode;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/utils/getRGBString.js
function getRGBString(red, green, blue) {
  return `rgb(${red}, ${green}, ${blue})`;
}
var getRGBString_default = getRGBString;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/helpers/ColorGenerator.js
var gap = 10;
var ColorGenerator = class {
  constructor() {
    this.red = 0;
    this.green = 0;
    this.blue = 1;
  }
  incrementColor(color) {
    this[color] = (this[color] + gap) % 256;
  }
  getNextColor() {
    const color = getRGBString_default(this.red, this.green, this.blue);
    this.incrementColor("blue");
    if (this.blue < gap) {
      this.incrementColor("green");
      if (this.green < gap) {
        this.incrementColor("red");
      }
    }
    return color;
  }
};
var ColorGenerator_default = ColorGenerator;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/canvas/Canvas.js
var CanvasComponent = class {
  constructor($el) {
    this.currentHoveringColor = "";
    const $hitEl = document.createElement("canvas");
    this.$el = $el;
    this.$hitEl = $hitEl;
    this.colorGenerator = new ColorGenerator_default();
  }
  clearCanvas() {
    const { height, width } = this.$el;
    this.getContext().clearRect(0, 0, width, height);
  }
  setMaxWidthAndHeight(height, width) {
    this.$hitEl.height = this.$el.height = height;
    this.$hitEl.width = this.$el.width = width;
  }
  getHitContext() {
    const ctx = this.$hitEl.getContext("2d");
    if (!ctx) {
      throw new Error("Cannot get 2d context");
    }
    return ctx;
  }
  getContext() {
    const ctx = this.$el.getContext("2d");
    if (!ctx) {
      throw new Error("Cannot get 2d context");
    }
    return ctx;
  }
  getNextColor() {
    return this.colorGenerator.getNextColor();
  }
  onHover(cb) {
    if (this.onHoverCB) {
      this.$el.removeEventListener("mousemove", this.onHoverCB);
    }
    this.onHoverCB = (event) => {
      const { pageX, pageY } = event;
      const { data: pixel } = this.getHitContext().getImageData(pageX - this.$el.offsetLeft, pageY - this.$el.offsetTop, 1, 1);
      const color = getRGBString_default(pixel[0], pixel[1], pixel[2]);
      if (this.currentHoveringColor !== color) {
        this.currentHoveringColor = color;
        cb(color);
      }
    };
    this.$el.addEventListener("mousemove", this.onHoverCB);
  }
  onClick(cb) {
    if (this.onClickCB) {
      this.$el.removeEventListener("click", this.onClickCB);
    }
    this.onClickCB = (event) => {
      const { pageX, pageY } = event;
      console.log(pageX, pageY);
      const { data: pixel } = this.getHitContext().getImageData(pageX - this.$el.offsetLeft, pageY - this.$el.offsetTop, 1, 1);
      cb(getRGBString_default(pixel[0], pixel[1], pixel[2]));
    };
    this.$el.addEventListener("click", this.onClickCB);
  }
};
var Canvas_default = CanvasComponent;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/enumns/VisualizationType.js
var VisualizationType;
(function(VisualizationType2) {
  VisualizationType2[VisualizationType2["SIMPLE"] = 0] = "SIMPLE";
  VisualizationType2[VisualizationType2["PRETTY"] = 1] = "PRETTY";
  VisualizationType2[VisualizationType2["EXPANDABLE"] = 2] = "EXPANDABLE";
  VisualizationType2[VisualizationType2["HIGHLIGHT"] = 3] = "HIGHLIGHT";
})(VisualizationType || (VisualizationType = {}));

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/utils/tree.js
function getMaxLeafNodesFromHeight(treeHeight) {
  return Math.pow(2, treeHeight - 1);
}
function getCanvasWidthFromMaxNodeSpacing(maxNodes) {
  return (maxNodes + 2) * theme_default.leafNodeSpace;
}
function getXPositionFromGivenHorizontalNodePosition(nodes) {
  return nodes * theme_default.leafNodeSpace;
}
function getCanvasHeightFromTreeHeight(treeHeight) {
  return treeHeight * theme_default.lineHeight;
}
function getRequiredAndActualHeightAndWidth(maxNodeSpacing, heightOfTree, maxWidth, maxHeight) {
  const maxCanvasWidthRequired = getCanvasWidthFromMaxNodeSpacing(maxNodeSpacing);
  const maxCanvasHeightRequired = getCanvasHeightFromTreeHeight(heightOfTree + 1);
  const actualMaxWidth = maxCanvasWidthRequired > maxWidth ? maxCanvasWidthRequired : maxWidth;
  const actualMaxHeight = maxCanvasHeightRequired > maxHeight ? maxCanvasHeightRequired : maxHeight;
  return {
    maxCanvasHeightRequired,
    maxCanvasWidthRequired,
    actualMaxHeight,
    actualMaxWidth
  };
}

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/strokes/BezierCurve.js
var BezierCurve = class {
  constructor(color, start, cp1, cp2, end) {
    const { x: xStart, y: yStart } = start;
    const { x: cp1x, y: cp1y } = cp1;
    const { x: cp2x, y: cp2y } = cp2;
    const { x: xEnd, y: yEnd } = end;
    this.color = color;
    this.xStart = xStart;
    this.yStart = yStart;
    this.cp1x = cp1x;
    this.cp1y = cp1y;
    this.cp2x = cp2x;
    this.cp2y = cp2y;
    this.xEnd = xEnd;
    this.yEnd = yEnd;
  }
  draw(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.xStart, this.yStart);
    ctx.strokeStyle = this.color;
    ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.xEnd, this.yEnd);
    ctx.stroke();
  }
};
var BezierCurve_default = BezierCurve;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js
function connectPointsWithBezierCurve(canvasComponent, horizontalConfig, verticalConfig) {
  const { xStart, xEnd } = horizontalConfig;
  const { yStart, yEnd } = verticalConfig;
  const halfY = (yStart + yEnd) / 2;
  const halfX = (xStart + xEnd) / 2;
  const berzierCurve = new BezierCurve_default(theme_default.strokeColor, { x: xStart, y: yStart }, { x: halfX, y: halfY }, { x: xEnd, y: halfY }, { x: xEnd, y: yEnd });
  berzierCurve.draw(canvasComponent.getContext());
}
var connectPointsWithBezierCurve_default = connectPointsWithBezierCurve;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/canvas/drawPrettyBinaryTree.js
var animationFrameId;
var hoveredColorId;
var spacingMap;
function requestAnimationFrame(root, canvasComponent, position, highlightMode) {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  animationFrameId = window.requestAnimationFrame(() => {
    canvasComponent.clearCanvas();
    const requiredRedraw = recursivelyDrawNodes(root, canvasComponent, position, highlightMode);
    if (requiredRedraw) {
      requestAnimationFrame(root, canvasComponent, position, highlightMode);
    }
  });
}
function drawSingleNode(node, comp, position, highlightMode) {
  const { x, y } = position;
  node.nodeCircle.setCoordinates(x, y);
  const colorId = node.nodeCircle.draw(comp);
  if (colorId === hoveredColorId && highlightMode) {
    return node.nodeCircle.grow();
  } else {
    return node.nodeCircle.restoreCircle();
  }
}
function recursivelyDrawNodes(root, canvasComponent, position, highlightMode) {
  const { x: xPosition, y: yPosition } = position;
  let requiredRedraw = drawSingleNode(root, canvasComponent, { x: xPosition, y: yPosition }, highlightMode);
  root.nodeCircle.setCoordinates(xPosition, yPosition);
  root.nodeCircle.draw(canvasComponent);
  const { left, right } = spacingMap.get(root);
  if (root.left) {
    const leftOfLeft = spacingMap.get(root.left).left;
    const childYPosition = yPosition + theme_default.lineHeight;
    const leftPosition = {
      x: xPosition - getXPositionFromGivenHorizontalNodePosition(left - leftOfLeft),
      y: childYPosition
    };
    requiredRedraw = recursivelyDrawNodes(root.left, canvasComponent, leftPosition, highlightMode) || requiredRedraw;
    connectPointsWithBezierCurve_default(canvasComponent, {
      xStart: xPosition,
      xEnd: leftPosition.x
    }, {
      yStart: yPosition + root.nodeCircle.getRadius(),
      yEnd: childYPosition - root.left.nodeCircle.getRadius()
    });
  }
  if (root.right) {
    const rightOfRight = spacingMap.get(root.right).right;
    const childYPosition = yPosition + theme_default.lineHeight;
    const rightPosition = {
      x: xPosition + getXPositionFromGivenHorizontalNodePosition(right - rightOfRight),
      y: childYPosition
    };
    requiredRedraw = recursivelyDrawNodes(root.right, canvasComponent, rightPosition, highlightMode) || requiredRedraw;
    connectPointsWithBezierCurve_default(canvasComponent, {
      xStart: xPosition,
      xEnd: rightPosition.x
    }, {
      yStart: yPosition + root.nodeCircle.getRadius(),
      yEnd: childYPosition - root.right.nodeCircle.getRadius()
    });
  }
  return requiredRedraw;
}
function calculateSpacingMapRecursively(root) {
  const left = root.left ? calculateSpacingMapRecursively(root.left) + 0.5 : 0;
  const right = root.right ? calculateSpacingMapRecursively(root.right) + 0.5 : 0;
  spacingMap.set(root, {
    left,
    right
  });
  return left + right;
}
function drawPrettyBinaryTree(root, canvasComponent, options) {
  spacingMap = /* @__PURE__ */ new Map();
  const maxNodeSpacing = calculateSpacingMapRecursively(root);
  const heightOfTree = root.getHeight();
  const { maxHeight, maxWidth, highlightMode } = options;
  const { maxCanvasWidthRequired, actualMaxHeight, actualMaxWidth } = getRequiredAndActualHeightAndWidth(maxNodeSpacing, heightOfTree, maxWidth, maxHeight);
  const left = spacingMap.get(root).left;
  const midPointInCanvas = actualMaxWidth / 2;
  const xStart = midPointInCanvas - maxCanvasWidthRequired / 2;
  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);
  canvasComponent.onHover((color) => {
    hoveredColorId = color;
    requestAnimationFrame(root, canvasComponent, {
      x: xStart + getXPositionFromGivenHorizontalNodePosition(left + 1),
      y: getCanvasHeightFromTreeHeight(0.5)
    }, Boolean(highlightMode));
  });
  requestAnimationFrame(root, canvasComponent, {
    x: xStart + getXPositionFromGivenHorizontalNodePosition(left + 1),
    y: getCanvasHeightFromTreeHeight(0.5)
  }, Boolean(highlightMode));
}
var drawPrettyBinaryTree_default = drawPrettyBinaryTree;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/canvas/drawExpandableBinaryTree.js
var animationFrameId2;
var globalPathArray;
var hoveredColorId2;
var colorIdToPathMap = /* @__PURE__ */ new Map();
function requestAnimationFrame2(root, comp, options) {
  if (animationFrameId2) {
    cancelAnimationFrame(animationFrameId2);
  }
  animationFrameId2 = window.requestAnimationFrame(() => animationFrameCB(root, comp, options));
}
function getNodeHeightFromGlobalPathArray() {
  return globalPathArray.length + 1;
}
function getNodeWidthFromGlobalPathArray() {
  let left = 0;
  let right = 0;
  let current = 0;
  for (const childDirection of globalPathArray) {
    if (childDirection === "left") {
      current -= 1;
    } else {
      current += 1;
    }
    if (current < 0) {
      left = Math.max(Math.abs(current), left);
    } else {
      right = Math.max(current, right);
    }
  }
  return {
    left,
    right
  };
}
function drawSingleNode2(node, comp, pathArray, position) {
  const { x, y } = position;
  const doesNodeHaveChildren = Boolean(node.left || node.right);
  node.nodeCircle.setCoordinates(x, y);
  const colorId = node.nodeCircle.draw(comp);
  colorIdToPathMap.set(colorId, pathArray);
  if (colorId === hoveredColorId2 && doesNodeHaveChildren) {
    return node.nodeCircle.grow();
  } else {
    return node.nodeCircle.restoreCircle();
  }
}
function drawChildren(node, comp, xPosition, nodeHeight, pathArray) {
  const currentHeight = getCanvasHeightFromTreeHeight(nodeHeight);
  const childHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);
  let requiredRedraw = false;
  if (node.left) {
    const currentPathArray = node.left.left || node.left.right ? [...pathArray, "left"] : [...pathArray];
    const xLeft = xPosition - 0.5 * theme_default.leafNodeSpace;
    requiredRedraw = drawSingleNode2(node.left, comp, currentPathArray, {
      x: xLeft,
      y: childHeight
    }) || requiredRedraw;
    connectPointsWithBezierCurve_default(comp, {
      xStart: xPosition,
      xEnd: xLeft
    }, {
      yStart: currentHeight + node.nodeCircle.getRadius(),
      yEnd: childHeight - node.left.nodeCircle.getRadius()
    });
  }
  if (node.right) {
    const currentPathArray = node.right.left || node.right.right ? [...pathArray, "right"] : [...pathArray];
    const xRight = xPosition + 0.5 * theme_default.leafNodeSpace;
    requiredRedraw = drawSingleNode2(node.right, comp, currentPathArray, {
      x: xRight,
      y: childHeight
    }) || requiredRedraw;
    connectPointsWithBezierCurve_default(comp, {
      xStart: xPosition,
      xEnd: xRight
    }, {
      yStart: currentHeight + node.nodeCircle.getRadius(),
      yEnd: childHeight - node.right.nodeCircle.getRadius()
    });
  }
  return requiredRedraw;
}
function drawAllNodes(root, comp, xRootPosition) {
  let currentNode = root;
  let xPosition = xRootPosition;
  let currentNodeHeight = 0.5;
  const currentPathArray = [];
  let requiredRedraw = drawSingleNode2(root, comp, [...currentPathArray], {
    x: xPosition,
    y: getCanvasHeightFromTreeHeight(currentNodeHeight)
  });
  for (const currentPath of globalPathArray) {
    requiredRedraw = drawChildren(currentNode, comp, xPosition, currentNodeHeight, currentPathArray) || requiredRedraw;
    if (currentPath === "left") {
      currentNode = currentNode.left;
      xPosition = xPosition - 0.5 * theme_default.leafNodeSpace;
      currentPathArray.push("left");
    } else {
      currentNode = currentNode.right;
      xPosition = xPosition + 0.5 * theme_default.leafNodeSpace;
      currentPathArray.push("right");
    }
    currentNodeHeight += 1;
  }
  requiredRedraw = drawChildren(currentNode, comp, xPosition, currentNodeHeight, currentPathArray) || requiredRedraw;
  return requiredRedraw;
}
function animationFrameCB(root, comp, options) {
  const nodeHeight = getNodeHeightFromGlobalPathArray();
  const { left: leftNodeWidth, right: rightNodeWidth } = getNodeWidthFromGlobalPathArray();
  const requiredHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);
  const requiredWidth = getCanvasWidthFromMaxNodeSpacing(leftNodeWidth + rightNodeWidth);
  const actualHeight = Math.max(requiredHeight, options.maxHeight);
  const actualWidth = Math.max(requiredWidth, options.maxWidth);
  const xStart = actualWidth / 2 - requiredWidth / 2;
  comp.setMaxWidthAndHeight(actualHeight, actualWidth);
  colorIdToPathMap = /* @__PURE__ */ new Map();
  const requiredRedraw = drawAllNodes(root, comp, xStart + getXPositionFromGivenHorizontalNodePosition(leftNodeWidth + 1));
  if (requiredRedraw) {
    requestAnimationFrame2(root, comp, options);
  }
}
function drawExpandableBinaryTree(root, canvasComponent, options) {
  globalPathArray = [];
  canvasComponent.onClick((color) => {
    globalPathArray = colorIdToPathMap.get(color) || globalPathArray;
    requestAnimationFrame2(root, canvasComponent, options);
  });
  canvasComponent.onHover((color) => {
    hoveredColorId2 = color;
    requestAnimationFrame2(root, canvasComponent, options);
  });
  requestAnimationFrame2(root, canvasComponent, options);
}
var drawExpandableBinaryTree_default = drawExpandableBinaryTree;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/canvas/drawSimpleBinaryTree.js
function recursivelyDrawNodes2(root, canvasComponent, currentLine, horizontalConfig) {
  const { xStart, xEnd } = horizontalConfig;
  const xPosition = (xStart + xEnd) / 2;
  const yPosition = currentLine * theme_default.lineHeight;
  root.nodeCircle.setCoordinates(xPosition, yPosition);
  root.nodeCircle.draw(canvasComponent);
  if (root.left) {
    recursivelyDrawNodes2(root.left, canvasComponent, currentLine + 1, {
      xStart,
      xEnd: xPosition
    });
    connectPointsWithBezierCurve_default(canvasComponent, {
      xStart: xPosition,
      xEnd: (xStart + xPosition) / 2
    }, {
      yStart: yPosition + theme_default.radius,
      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme_default.radius
    });
  }
  if (root.right) {
    recursivelyDrawNodes2(root.right, canvasComponent, currentLine + 1, {
      xStart: xPosition,
      xEnd
    });
    connectPointsWithBezierCurve_default(canvasComponent, {
      xStart: xPosition,
      xEnd: (xPosition + xEnd) / 2
    }, {
      yStart: yPosition + theme_default.radius,
      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme_default.radius
    });
  }
}
function drawSimpleBinaryTree(root, canvasComponent, options) {
  const heightOfTree = root.getHeight();
  const maxNumberOfLeafNodes = getMaxLeafNodesFromHeight(heightOfTree);
  const { maxHeight, maxWidth } = options;
  const { maxCanvasWidthRequired, actualMaxHeight, actualMaxWidth } = getRequiredAndActualHeightAndWidth(maxNumberOfLeafNodes, heightOfTree, maxWidth, maxHeight);
  const midPointInCanvas = actualMaxWidth / 2;
  const xStart = midPointInCanvas - maxCanvasWidthRequired / 2 + theme_default.leafNodeSpace;
  const xEnd = midPointInCanvas + maxCanvasWidthRequired / 2 - theme_default.leafNodeSpace;
  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);
  recursivelyDrawNodes2(root, canvasComponent, 0.5, { xStart, xEnd });
}
var drawSimpleBinaryTree_default = drawSimpleBinaryTree;

// node_modules/.pnpm/binary-tree-visualizer@2.1.5/node_modules/binary-tree-visualizer/lib/canvas/drawBinaryTree.js
var canvasMap = /* @__PURE__ */ new Map();
function drawBinaryTree(root, canvasElement, options = {}) {
  const { type = VisualizationType.SIMPLE, maxHeight = window.innerHeight, maxWidth = window.innerWidth } = options;
  const canvasComponent = canvasMap.get(canvasElement) || new Canvas_default(canvasElement);
  canvasMap.set(canvasElement, canvasComponent);
  switch (type) {
    case VisualizationType.PRETTY:
      drawPrettyBinaryTree_default(root, canvasComponent, {
        maxHeight,
        maxWidth
      });
      break;
    case VisualizationType.EXPANDABLE:
      drawExpandableBinaryTree_default(root, canvasComponent, {
        maxHeight,
        maxWidth
      });
      break;
    case VisualizationType.HIGHLIGHT:
      drawPrettyBinaryTree_default(root, canvasComponent, {
        maxHeight,
        maxWidth,
        highlightMode: true
      });
      break;
    default:
      drawSimpleBinaryTree_default(root, canvasComponent, {
        maxHeight,
        maxWidth
      });
      break;
  }
}
var drawBinaryTree_default = drawBinaryTree;
export {
  BinarySearchTreeNode_default as BinarySearchTreeNode,
  BinaryTreeNode_default as BinaryTreeNode,
  Canvas_default as CanvasComponent,
  VisualizationType,
  drawBinaryTree_default as drawBinaryTree,
  setTheme
};
//# sourceMappingURL=binary-tree-visualizer.js.map
